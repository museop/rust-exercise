# Tokio 라이브러리 학습  

## Phase 1: 비동기 기초

이 단계의 핵심은 **"Rust의 비동기 함수는 호출한다고 바로 실행되지 않는다"** 는 사실을 깨닫는 것입니다. 다른 언어(JavaScript, Go 등)와 가장 큰 차이점이기도 합니다.

### 핵심 개념 잡기

#### A. 동기(Sync) vs 비동기(Async)
- 동기: 커피를 주문하고 커피가 나올 때까지 카운터 앞에서 멍하니 기다리는 것. (스레드 차단)
- 비동기: 진동벨을 받고 자리에 가서 폰을 하다가, 벨이 울리면 커피를 가지러 가는 것. (스레드 비차단, 효율적 자원 사용)

#### B. Future와 게으름(Laziness)
Rust의 비동기 작업은 게으릅니다(Lazy). `async fn`을 호출하면 코드가 실행되는 것이 아니라, **"나중에 실행할 수 있는 작업 계획서"** 인 `Future`라는 객체를 반환합니다. 이 계획서를 실행기(Runtime)에 등록하거나 `.await`를 해야 비로소 움직입니다.

#### C. Tokio 런타임
Rust 표준 라이브러리는 `Future`라는 껍데기만 제공합니다. 실제로 CPU를 할당해서 작업을 돌려주는 엔진이 없습니다. Tokio가 바로 그 엔진(런타임) 역할을 합니다.

### `#[tokio::main]`의 정체
`async fn main()`은 사실 Rust 문법상 존재할 수 없습니다. 운영체제는 일반적인 동기 함수인 main만 실행할 수 있기 때문입니다.

우리가 붙인 #[tokio::main] 매크로는 코드를 컴파일할 때 아래와 같이 자동으로 변환해 줍니다.

```rust
// 실제로는 이렇게 변환되어 실행됩니다
fn main() {
    // 1. 런타임 생성
    let rt = tokio::runtime::Runtime::new().unwrap();
    
    // 2. 런타임 위에서 비동기 코드 실행 (block_on)
    rt.block_on(async {
        say_hello().await;
    });
}
```

## Phase 2: 태스크 관리(Task Management

Phase 1에서는 비동기 함수를 정의하고 실행하는 법을 배웠지만, 코드는 여전히 순서대로(직렬로) 실행되었습니다. Phase 2의 핵심은 `tokio::spawn`을 사용하여 작업을 동시에(병렬로) 실행하는 것입니다. 마치 요리할 때 물을 올려두고(백그라운드), 동시에 야채를 써는 것과 같습니다.

### `tokio::spawn`: 비동기의 날개

Tokio에서 가장 중요한 함수 중 하나입니다.

- 역할: 새로운 비동기 작업을 생성하여 Tokio 런타임에게 "이거 백그라운드에서 실행해줘"라고 던집니다.
- 특징: 운영체제의 스레드(OS Thread)를 만드는 것보다 훨씬 가볍습니다. 수천, 수만 개를 만들어도 부담이 적습니다. (이를 그린 스레드라고도 부릅니다.)

### 핵심 개념 깊이 보기 (중요!)

Rust 초보자가 `tokio::spawn`을 쓸 때 가장 많이 만나는 에러인 `Send`와 `'static` 제약을 이해해야 합니다.

#### Q. 왜 `spawn` 안으로 변수를 넘길 때 `move`를 써야 하나요?

Tokio 런타임은 멀티 스레드(worker thread)를 사용합니다. 당신이 만든 태스크(Task A)가 지금은 1번 스레드에서 돌다가, 잠시 쉬고 난 뒤에는 2번 스레드에서 깨어날 수도 있습니다. 또한, `main` 함수가 태스크보다 먼저 끝날 수도 있습니다. 그래서 태스크는 자신이 사용하는 모든 데이터의 소유권(Ownership)을 완전히 가져야 합니다. 외부 변수를 빌려 쓰는(Reference) 것은 기본적으로 금지됩니다. (그래서 `'static` 수명이 필요하다고 에러가 뜹니다.)

#### Q. `JoinHandle`은 무엇인가요?

`tokio::spawn`의 반환값입니다.

- 기다리기: `.await`를 호출하면 해당 태스크가 끝날 때까지 기다립니다.
- 결과 받기: 태스크 내부에서 리턴한 값을 받아올 수 있습니다.
- 취소하기: `handle.abort()`를 호출하면 실행 중인 태스크를 강제 중단시킬 수 있습니다.

## Phase 3: 비동기 I/O와 네트워킹

Tokio의 존재 이유이자 가장 빛나는 분야입니다. Phase 2에서 배운 `tokio::spawn`을 무기로, 수천 명의 클라이언트를 동시에 처리하는 고성능 TCP 서버를 만들어 보겠습니다.

### 비동기 I/O의 핵심 개념

네트워크 프로그래밍을 해보셨다면 소켓(Socket)을 다루는 법을 아실 겁니다. Tokio도 비슷하지만, **Blocking(차단)** 되지 않는다는 점이 다릅니다.

- `TcpListener`: 들어오는 연결을 기다리는 문지기입니다. `accept()` 할 때 스레드를 멈추지 않고 비동기적으로 대기합니다.
- `TcpStream`: 연결된 전화선(소켓)입니다. 데이터를 읽고 씁니다.
- `AsyncReadExt`, `AsyncWriteExt`: (매우 중요) Rust 표준 `std::io` 대신 Tokio의 `io` 트레이트를 사용해야 합니다. 이 트레이트들을 `use` 하지 않으면 `read`나 `write` 메서드가 보이지 않습니다.

## Phase 4: 비동기 동기화 (Shared State)

Phase 3에서는 각 클라이언트가 격리되어 있었지만, 이제 **"서로 다른 태스크(Task)들이 데이터를 공유하는 방법"** 을 배울 차례입니다. 예를 들어, 채팅방 참여자 목록이나, 접속자 수 카운터 같은 데이터가 필요할 때죠.

Rust에서 이는 매우 까다로운 주제입니다. Rust 컴파일러는 데이터 경쟁(Race Condition)을 원천 봉쇄하기 위해 소유권 규칙을 엄격하게 적용하기 때문입니다.

### `Arc`와 `Mutex`

Tokio뿐만 아니라 Rust 동시성 프로그래밍의 공식과도 같은 패턴입니다.

- `Arc` (Atomic Reference Counting):
  - 문제: Rust는 하나의 데이터에 하나의 주인(Owner)만 있어야 합니다. 하지만 여러 태스크가 동시에 데이터에 접근해야 합니다.
  - 해결: `Arc`는 데이터의 "공동 소유"를 가능하게 해주는 스마트 포인터입니다. 복제(clone)할 때마다 카운터가 올라가고, 모두 사라지면 데이터가 지워집니다.
- `Mutex` (Mutual Exclusion):
  - 문제: 여러 명이 동시에 데이터를 고치면 엉망이 됩니다.
  - 해결: 한 번에 한 명만 데이터에 접근하도록 "자물쇠"를 채웁니다.

결론: `Arc<Mutex<데이터>>` 형태로 감싸면, 여러 태스크가 안전하게 데이터를 공유하고 수정할 수 있습니다.

### 주의: `std::sync::Mutex` vs `tokio::sync::Mutex`

이 부분이 Phase 4의 핵심이자 가장 많이 실수하는 부분입니다. 두 가지 `Mutex`가 있습니다.

`std::sync::Mutex` (표준 라이브러리)
- 특징: 락이 걸려 있으면 스레드 자체를 멈춥니다(Blocking).
- 용도: 단순한 데이터(숫자, 작은 구조체)를 아주 잠깐 수정할 때 사용합니다. 속도가 빠릅니다.
- 금지사항: 락을 건 상태로 `.await`를 호출하면 절대 안 됩니다! (데드락 발생 위험)

`tokio::sync::Mutex` (Tokio 라이브러리)
- 특징: 락이 걸려 있으면 태스크만 잠시 쉬게 하고, 스레드는 다른 일을 하러 갑니다(Non-blocking).
- 용도: 락을 건 상태로 파일 IO나 네트워크 통신 등 오래 걸리는 비동기 작업(`.await`)을 해야 할 때 사용합니다.
- 단점: 표준 Mutex보다 약간 느리고 무겁습니다.

이번 예제 전략: 단순히 방문자 숫자만 카운트할 것이므로, 속도가 빠르고 가벼운 **std::sync::Mutex**를 사용하겠습니다.

### 핵심 정리 및 심화 질문 
1. `Arc::clone`: 데이터를 복사하는 게 아니라 소유권 공유 티켓을 하나 더 끊는 것입니다. `spawn` 블록에 넘겨주기 위해 필수적입니다.
2. Lock Scope: `let mut num = ...` 변수가 유효한 범위(중괄호 {}) 내에서만 락이 유지됩니다. 범위를 벗어나면 락이 자동으로 풀립니다. 이를 이용해 락을 잡고 있는 시간을 최소화해야 성능이 좋아집니다.

한계점: `Mutex`는 강력하지만, 복잡한 로직에서 사용하면 코드가 지저분해지고 데드락(Deadlock) 위험이 있습니다. 그래서 Tokio 생태계에서는 **"메모리를 공유해서 통신하지 말고, 통신해서 메모리를 공유하라"** 는 Go 언어의 철학을 따르기도 합니다. 락을 쓰는 대신 **메시지(채널)**를 주고받는 방식이죠.

## Phase 5: 채널을 이용한 통신 (Channels)

Phase 4의 Mutex는 "하나의 방(데이터)"을 서로 차지하려고 경쟁하는 방식이었다면, Phase 5의 **채널(Channel)** 은 "우체통"에 편지를 넣는 방식입니다. 줄을 서서 기다릴 필요 없이 편지를 넣고 자기 할 일을 하러 가면 되니 흐름이 훨씬 매끄럽습니다.

Rust Tokio 프로그래밍에서 가장 권장되는 패턴입니다.

### Tokio 채널 종류

Tokio는 상황에 따라 4가지 종류의 채널을 제공합니다. (모두 tokio::sync 모듈에 있습니다.)

|채널 종류|설명|용도|
|--|--|--|
|`mpsc`|(가장 중요)Multi-Producer, Single-Comsumer. 송신자는 여러 명, 수신자는 한 명.|중앙 처리 장치, 로그 수집기|
|`oneshot`|일대일(1:1), 딱 한 번만 메시지를 보내고 채널이  닫힘.|작업 완료 신호, 결과 값 반환|
|`broadcast`|송신자는 한 명(또는 여러 명), 수신자는 여러 명. 모든 수신자가 같은 메시지를 받음|채팅방, 이벤트 알림|
|`watch`|단일 값의 최신 상태만 유지.|설정(Config) 변경 감지|

### Q. 채널에 데이터를 쓸 때, 데이터가 복사되나요? 아니면 소유권만 이동하나요?
#### 메모리 동작 원리 (Stack vs Heap)
`String`은 내부적으로 두 부분으로 나뉩니다.
1. 스택(Stack): 데이터가 어디 있는지 가리키는 포인터, 길이, 용량 정보 (매우 작음, 24바이트 정도).
2. 힙(Heap): 실제 문자열 데이터 ("Hello World..." 같은 긴 텍스트).

채널에 send(msg)를 할 때 일어나는 일:
- 힙(Heap)에 있는 실제 데이터: 가만히 있습니다. (복사 안 됨 ❌)
- 스택(Stack)에 있는 정보: 채널을 통해 수신자에게 전달됩니다. (이것만 복사됨 ✅)
- 소유권(Ownership): 송신자에게서 수신자로 넘어갑니다. 이제 송신자는 msg를 더 이상 건드릴 수 없습니다.

#### 예외 케이스: `Copy` 타입
만약 보내는 데이터가 `i32`, `bool`, `f64` 같은 기본 타입(Primitive Type)이라면 이야기가 다릅니다. 이들은 `Copy` 트레이트가 구현되어 있어서, 값 자체가 복사되어 넘어갑니다.

- `String`, `Vec`, `Box` 등: Move (소유권 이동, 힙 데이터 유지)
- `i32`, `u8`, `bool`: Copy (값 복사, 원본도 계속 사용 가능)

### Q. 언제 채널을 쓰고 안제 Mutex를 쓰나요?
Channels (`mpsc`):
- 데이터의 흐름이 있을 때 (A에서 B로 전달).
- 소유권을 아예 넘겨버리고 싶을 때.
- 작업 큐(Job Queue)를 만들 때.
- 권장: 대부분의 비동기 작업 로직.

`Mutex` / `RwLock`:
- 데이터가 제자리에 있고 여러 명이 조회/수정해야 할 때.
- 설정 값, 캐시 데이터, 거대한 공유 상태.
- 권장: 상태(State)를 저장해야 할 때.


## Phase 6: 제어 흐름 (`tokio::select!`)

지금까지는 작업을 실행(`spawn`)하고 끝날 때까지 기다리거나(`.await`), 채널로 데이터를 주고받았습니다. 하지만 실전에서는 이런 상황이 자주 발생합니다.

"1초 안에 응답이 없으면 취소해줘." "사용자가 Ctrl+C를 누르면 서버를 안전하게 꺼줘." "두 개의 서버에 요청을 보내고, 더 빨리 응답 오는 것만 쓸래."

이런 **"선착순 경쟁"** 로직을 처리하는 마법사가 바로 `tokio::select!` 매크로입니다.

### `tokio::select!`의 핵심 원리
`select!`는 여러 개의 비동기 작업(`Future`)을 동시에 기다립니다. 그리고 가장 먼저 완료된 작업(Winner) 하나만 실행하고, **나머지 작업(Loser)들은 즉시 취소(Drop)** 해 버립니다.

마치 달리기 시합과 같습니다. 1등이 결승선을 통과하는 순간, 경기가 종료되고 나머지 선수들은 달리기를 멈춥니다.


### 주의할 점: "취소(Cancellation)"의 의미
`select!`에서 선택받지 못한 `Future`는 Drop됩니다. Rust에서 Drop된다는 것은 곧 취소를 의미합니다.

이게 왜 중요할까요? 만약 어떤 작업이 "파일에 데이터를 쓰는 중"이었는데 중간에 취소되면 어떻게 될까요? 파일 내용이 반만 써진 상태로 남을 수 있습니다.

```rust
// ❌ 위험한 코드
// 파일에 100MB를 쓰는 함수를 select!에 넣으면, 중간에 끊길 수 있음.
tokio::select! {
    _ = write_huge_file() => { ... },
    _ = cancel_signal() => { ... }
}

// ✅ 안전한 코드 (Tokio spawn 활용)
// 파일을 쓰는 작업은 별도 태스크로 던져버려서(Detach) 취소되지 않게 하고,
// 결과만 기다리거나 아예 독립적으로 돌게 둡니다.
tokio::spawn(async {
    write_huge_file().await; // 얘는 select와 상관없이 끝까지 돔
});
```

데이터 무결성이 중요한 작업(Atomic Operation)은 `select!`의 가지(branch)에 직접 넣을 때 주의해야 합니다. **중간에 끊겨도 괜찮은 작업(읽기, 대기, 수신 등) 위주로 사용하는 것이 좋습니다.**

## Phase 7: 심화 및 에코시스템
지금까지 여러분은 `spawn`으로 태스크를 띄우고, `channel`로 대화하며, `mutex`로 데이터를 나누고, `select!`로 심판을 보는 법을 배웠습니다. 이것만으로도 웬만한 서버는 다 만들 수 있습니다.

하지만 **"혼자서 처음부터 다 짜는 것(Reinventing the wheel)"** 은 비효율적입니다. Tokio 위에는 이미 수많은 고수들이 쌓아 올린 견고한 생태계가 있습니다. Phase 7에서는 **"프로덕션 레벨"** 로 가기 위해 무엇을 더 알아야 하는지 지도를 그려드리겠습니다.

### 1. 바이트 스트림의 악몽 탈출: `tokio-util` & `Codec`
Phase 3에서 `read`로 데이터를 읽을 때 버퍼(`[u8; 1024]`)를 썼던 것 기억나시나요? 실전 TCP 통신에서는 패킷이 잘려서 오거나(Fragmentation), 뭉쳐서 올 수 있습니다. 이걸 `if/else`로 직접 파싱하면 코드가 지옥이 됩니다.

- 문제: TCP는 스트림(물줄기)이지 메시지(편지) 단위가 아니다.
- 해결: **tokio-util의 Codec** 을 사용합니다.
- 원리:
  - `Decoder`: 들어오는 바이트(Bytes)를 내가 정의한 객체(Struct)로 변환.
  - `Encoder`: 내 객체(Struct)를 바이트(Bytes)로 변환.
  - `Framed`: 소켓과 코덱을 결합하여, 마치 채널처럼 객체를 `send/next` 할 수 있게 해주는 래퍼.
- 팁: 직접 파싱하지 마세요. `LinesCodec`(줄바꿈 기준)이나 `LengthDelimitedCodec`(길이 헤더 기준)을 쓰면 복잡한 네트워크 버퍼링 처리를 라이브러리가 대신 해줍니다.


### 2. 비동기 로깅의 표준:`tracing`
`println!`은 비동기 환경에서 최악의 디버깅 도구입니다. 태스크들이 수시로 스레드를 옮겨 다니기 때문에, 로그가 뒤죽박죽 섞여서 "누가, 언제, 왜" 에러를 냈는지 추적하기 불가능합니다.

- 해결: `tracing` 크레이트 사용.
- 특징:
  - Spans (구간): "A 태스크 시작" ~ "A 태스크 끝" 사이의 맥락을 유지합니다.
  - Structured Logging: 단순 텍스트가 아니라 `key=value` 형태로 로그를 남겨 검색이 쉽습니다.
  - Async Aware: `.await` 포인트에서 태스크가 멈췄다가 다시 실행될 때도 문맥을 잃지 않습니다.

```rust
// 함수 위에 이 한 줄만 붙이면, 이 함수의 진입/종료/인자 값이 자동으로 로깅됩니다.
#[tracing::instrument]
async fn process_request(id: u32) { ... }
```

### 3. 비동기 작업 관리자: `tokio-console`
윈도우의 '작업 관리자'나 리눅스의 `top` 같은 도구가 Tokio에도 있습니다.

- 기능: 터미널에서 실행 중인 비동기 태스크들의 목록, 실행 시간, 대기 시간 등을 실시간 그래프로 보여줍니다.
- 용도: "왜 서버가 느리지?", "어떤 태스크가 멈쳐있지(Deadlock)?" 같은 문제를 시각적으로 찾아낼 때 씁니다.

### Tokio 생태계 지도 (The Stack)
Tokio는 단순한 런타임이고, 그 위에 분야별로 사실상 표준(Standard)처럼 쓰이는 라이브러리들이 있습니다.

|분야|라이브러리|설명|
|--|--|--|
|웹 프레임워크|`Axum`|Tokio 팀이 직접 만든 차세대 웹 프레임워크. 매우 인기가 높습니다.|
|HTTP 클라이언트|`Reqwest`|Rust에서 가장 유명한 HTTP 클라이언트. 사용하기 정말 편합니다.|
|데이터베이스|`SQLx`|100% 비동기 Rust DB 드라이버. 컴파일 타임에 SQL 문법을 검사해 줍니다.|
|RPC|`Tonic`|gRPC의 Rust 구현체. 마이크로서비스 구축의 핵심입니다.|
|파일 시스템|`tokio::fs`|표준 `std::fs` 대신 사용하여 스레드 블로킹을 막습니다.|
.