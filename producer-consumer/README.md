# Rust 생산자-소비자 패턴 예제

이 프로젝트는 Rust에서 생산자-소비자(Producer-Consumer) 패턴을 구현하는 방법을 보여주는 예제 코드입니다.

## 개요

생산자-소비자 패턴은 하나 이상의 생산자 스레드가 작업을 생성하여 공유 데이터 구조(큐)에 넣고, 하나 이상의 소비자 스레드가 큐에서 작업을 꺼내 처리하는 동시성 디자인 패턴입니다.

이 예제는 두 가지 주요 시나리오를 다룹니다.

1.  **다중 생산자, 단일 소비자 (Multi-Producer, Single-Consumer)**
2.  **다중 생산자, 다중 소비자 (Multi-Producer, Multi-Consumer)**

## 실행 방법

프로젝트를 실행하려면 터미널에서 다음 명령어를 사용하세요.

```bash
cargo run
```

## 구현 상세

### 1. 다중 생산자, 단일 소비자

Rust의 표준 라이브러리인 `std::sync::mpsc` 채널은 "다중 생산자, 단일 소비자" 모델을 위해 설계되었습니다.

-   **송신자 (`Sender<T>` 또는 `tx`)**: 채널에 메시지를 보내는 역할. `tx`는 `clone()` 메서드를 통해 여러 복제본을 만들 수 있습니다. 이를 통해 여러 생산자 스레드가 각자의 `tx` 복제본으로 동시에 메시지를 보낼 수 있습니다.
-   **수신자 (`Receiver<T>` 또는 `rx`)**: 채널로부터 메시지를 받는 역할. `rx`는 복제할 수 없으며, 오직 하나의 소비자 스레드만 소유할 수 있습니다. 이는 메시지를 꺼내는 행위가 파괴적인 작업이기 때문에 데이터 경쟁을 원천적으로 방지하기 위함입니다.

### 2. 다중 생산자, 다중 소비자

"단일 소비자" 제약을 넘어 여러 소비자 스레드가 동시에 작업을 처리하게 하려면, 수신자(`rx`)를 여러 스레드가 안전하게 공유할 수 있는 방법이 필요합니다. 이를 위해 `Arc<Mutex<T>>`를 사용합니다.

-   **`Arc<T>` (Atomic Reference Counter)**: `Arc`는 데이터에 대한 소유권을 여러 스레드가 "공동 소유"할 수 있게 해줍니다. `Arc::clone()`을 호출하면 해당 데이터에 대한 참조 카운트만 증가시키므로, 여러 스레드에서 저비용으로 데이터에 접근할 수 있습니다.
-   **`Mutex<T>` (Mutual Exclusion)**: `Mutex`는 데이터에 대한 접근을 한 번에 하나의 스레드로 제한하는 "자물쇠" 역할을 합니다. 스레드는 데이터를 사용하기 전에 `lock()`을 호출하여 자물쇠를 획득해야 하며, 사용이 끝나면 자물쇠는 자동으로 해제됩니다.

## 핵심 개념: 왜 tx와 rx의 처리 방식이 다른가?

-   **`tx` (송신)**: 메시지를 채널에 **넣는** 행위는 비파괴적(non-destructive)입니다. 여러 스레드가 동시에 메시지를 보내도 채널이 내부적으로 알아서 순서를 관리해주므로 안전합니다. (마치 여러 사람이 하나의 우체통에 편지를 넣는 것과 같습니다.)

-   **`rx` (수신)**: 메시지를 채널에서 **꺼내는** 행위는 파괴적(destructive)입니다. 만약 여러 스레드가 동시에 메시지를 꺼내려 한다면 어떤 스레드가 메시지를 가져가야 할지 알 수 없는 "데이터 경쟁"이 발생합니다. `Mutex`는 이 문제를 해결하기 위해 한 번에 하나의 스레드만 `rx`에 접근하도록 보장해주는 장치입니다. `Arc`는 이 `Mutex`로 보호받는 `rx`를 여러 스레드에게 "빌려주는" 역할을 합니다.

이 조합을 통해 여러 소비자 스레드가 안전하게 하나의 채널에서 번갈아가며 작업을 꺼내 처리하는 "다중 소비자" 패턴을 구현할 수 있습니다. 