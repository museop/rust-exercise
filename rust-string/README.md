# Rust 문자열 

Rust의 문자열 시스템은 처음 접할 때 가장 혼란스러운 부분 중 하나입니다. 다른 언어와 달리 Rust는 메모리 안전성과 UTF-8 인코딩을 엄격하게 보장하기 때문에 여러 종류의 문자열 타입을 두고 있습니다.

핵심은 **"소유권(Ownership)"** 과 **"인코딩(Encoding)"** 의 차이를 이해하는 것입니다. 가장 중요한 타입들부터 체계적으로 정리해 드리겠습니다.

## 0. 요약: 소유(Owned) vs 대여(Borrowed) 패턴

Rust의 문자열 타입들은 일관된 패턴을 가지고 있습니다. 이 표를 기억하면 헷갈리지 않습니다.

|용도|소유(Owned) - 수정 가능, 힙 할당|대여(Borrowed) - 읽기 전용, 참조|특징|
|--|--|--|--|
|표준 문자열|`String`|`&str`|유효한 UTF-8 허용|
|OS 문자열|`OsString`|`&OsStr`|OS 호환 (Non-UTF-8 허용)|
|파일 경로|`PathBuf`|`Path`|파일 시스템 경로 조작 메서드 제공
|C 호환|`CString`|`&CStr`|Null-terminated(`\0`으로 끝남|

## 1. 핵심 문자열 타입: `String` vs `&str`

가장 많이 사용하게 될 표준 문자열 타입입니다. 이들은 항상 유효한 **UTF-8** 임이 보장됩니다.

`String` (소유한 문자열)
- 성격: 힙(Heap) 메모리에 할당되며, 크기를 조절할 수 있습니다(Growable).
- 비유: `Vec<u8>`과 거의 같습니다. 데이터 자체를 소유하고 있습니다.
- 용도: 문자열을 생성, 수정, 소유해야 할 때 사용합니다.
- 특징:
  - 수정 가능 (`push_str`, `pop` 등).
  - 런타임에 데이터가 생성될 때 주로 사용.

```rust
let mut s = String::from("Hello");
s.push_str(", World!"); // 수정 가능
```

`&str` (문자열 슬라이스)
- 성격: 어딘가에 저장된 UTF-8 데이터에 대한 **참조(View)** 입니다.
- 용도: 문자열을 읽기만 하거나, 함수 인자로 받을 때(유연성) 사용합니다.
- 특징:
  - 크기가 고정되어 있음 (수정 불가).
  - 바이너리 자체에 포함된 문자열 리터럴(`"hello"`)은 항상 `&'static str` 타입입니다.

```rust
let s1: String = String::from("hello");
let s2: &str = &s1; // s1을 빌려옴
let s3: &str = "literal"; // 바이너리 데이터 영역을 가리킴
```

## 2. 운영체제 및 파일 시스템: `OsString` vs `&OsStr`

`Rust`의 `String`은 반드시 UTF-8이어야 하지만, **운영체제(OS)** 는 그렇지 않을 수 있습니다.
- Windows: UTF-16과 유사한 방식을 사용.
- Linux: 임의의 바이트 시퀀스 허용.

이 간극을 메우기 위해 존재합니다.

`OsString` / `&OsStr`
- 용도: 환경 변수, 파일 이름 등 OS와 직접 상호작용할 때.
- 특징: UTF-8이 아닌 바이트 시퀀스도 담을 수 있습니다.
- 패턴: `String`과 `&str`의 관계처럼, `OsString`은 소유하고 `&OsStr`은 빌려옵니다.
- Note: `String`으로 변환하려면 `into_string()` 등을 사용해야 하며, UTF-8이 아닌 문자가 섞여 있으면 변환에 실패할 수 있습니다.

## 3. 파일 경로 특화: `PathBuf` vs `Path`

사실상 `OsString`의 래퍼(Wrapper)이지만, 파일 경로를 다루기 위한 편리한 메서드들이 추가된 타입입니다.

`PathBuf` (소유한 경로)
- 성격: `String`과 유사. 경로 데이터를 힙에 소유합니다.
- 용도: 경로를 조립하거나 변경해서 저장해둘 때.

`Path` (경로 슬라이스)
- 성격: `&str`과 유사. 경로 데이터에 대한 참조입니다.
- 용도: 경로를 읽거나 함수 인자로 받을 때.

## 4. C 언어 호환 (FFI): `CString` vs `&CStr`

C 언어의 문자열은 **Null Byte (\0)** 로 끝나는 특징이 있습니다. 반면 Rust 문자열은 길이를 저장하는 방식입니다. C 라이브러리와 통신할 때는 이 타입들을 써야 합니다.

`CString` / `&CStr`
- `CString`: 힙에 할당되며, 끝에 \0 문자가 포함된 문자열을 소유합니다. (Rust -> C 로 넘길 때)
- `&CStr`: C 스타일 문자열에 대한 참조입니다. (C -> Rust 로 받을 때)



## 실전 팁
- 함수 인자: 가능하면 `&str`이나 `&Path`를 사용하세요. (`String`이나 `PathBuf`를 넘겨줄 수도 있고, 리터럴도 넘겨줄 수 있어 훨씬 유연합니다.)
- 변환: `PathBuf` -> `String` 변환은 실패할 수 있습니다(파일 경로에 한글이 깨져있거나 특수 바이트가 있는 경우). 따라서 `to_string_lossy()` 같은 메서드를 자주 사용하게 됩니다.